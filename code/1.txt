(print ((lambda (x y z) (+ x y (square z))) 1 2 3))     // 12\n
(define (f x y) (let ((a (+ 1 (* x y))) (b (- 1 y))) (+ (* x (square a)) (* y b) (* a b))))
(dispalyln (f 3 4))        // 456\n
(define x 5)
(display (+ (let ((x 3)) (+ x (* x 10))) x))        // 38
(print (let ((x 3) (y (+ x 2))) (* x y)))           // 21\n
(define (add-rat x y) (make-rat (+ (* (numer x) (denom y)) (* (numer y) (denom x))) (* (denom x) (denom y))))
(define (sub-rat x y) (make-rat (- (* (numer x) (denom y)) (* (numer y) (denom x))) (* (denom x) (denom y))))
(define (mul-rat x y) (make-rat (* (numer x) (numer y)) (* (denom x) (denom y))))
(define (div-rat x y) (make-rat (* (numer x) (denom y)) (* (denom x) (numer y))))
(define (equal-rat? x y) (= (* (numer x) (denom y)) (* (numer y) (denom x))))
(define x (cons 1 (cons 2 '())))
(display (car x))       // 1
(display (cdr x))       // 2
(define x (list 1 2))
(define y (list 3 4))
(define z (cons x y))
(display (car (car z)))     // 1
(display (car (cdr z)))     // 3
(newline)       // \n
(print z)       // ((1 2) 3 4)\n
(define (make-rat n d) (list n d))
(define (numer x) (car x))
(define (denom x) (car (cdr x)))
(define (cat-rat x) (+ (* (numer x) 10) (denom x)))
(define one-half (make-rat 1 2))
(cat-rat one-half)", "12")
(define one-third (make-rat 1 3))
(cat-rat (add-rat one-half one-third))", "56")
(cat-rat (mul-rat one-half one-third))", "16")
(cat-rat (add-rat one-third one-third))", "69")
(define (gcd a b) (if (= b 0) a (gcd b (remainder a b))))
(define (make-rat n d) (let ((g (gcd n d))) (list (/ n g) (/ d g))))
(cat-rat (add-rat one-third one-third))", "23")
(define one-through-four (list 1 2 3 4))
(one-through-four", "(1 2 3 4)")
(car one-through-four)", "1")
(cdr one-through-four)", "(2 3 4)")
(car (cdr one-through-four))", "2")
(cons 10 one-through-four)", "(10 1 2 3 4)")
(cons 5 one-through-four)", "(5 1 2 3 4)")
(define (map proc items) (if (null? items) '() (cons (proc (car items)) (map proc (cdr items)))))
(map abs (list -10 2.5 -11.6 17))", "(10 2.5 11.6 17)")
(map (lambda (x) (* x x)) (list 1 2 3 4))", "(1 4 9 16)")
(define (scale-list items factor) (map (lambda (x) (* x factor)) items))")
(scale-list (list 1 2 3 4 5) 10)", "(10 20 30 40 50)")
(define (count-leaves x) (cond ((null? x) 0) ((not (pair? x)) 1) (else (+ (count-leaves (car x)) (count-leaves (cdr x))))))")
(define x (cons (list 1 2) (list 3 4)))")
(count-leaves x)", "4")
(count-leaves (list x x))", "8")
(define (odd? x) (= 1 (remainder x 2)))")
(define (filter predicate sequence) (cond ((null? sequence) '()) ((predicate (car sequence)) (cons (car sequence) (filter predicate (cdr sequence)))) (else (filter predicate (cdr sequence)))))")
(filter odd? (list 1 2 3 4 5))", "(1 3 5)")
(define (accumulate op initial sequence) (if (null? sequence) initial (op (car sequence) (accumulate op initial (cdr sequence)))))")
(accumulate + 0 (list 1 2 3 4 5))", "15")
(accumulate * 1 (list 1 2 3 4 5))", "120")
(accumulate cons '() (list 1 2 3 4 5))", "(1 2 3 4 5)")
(define (enumerate-interval low high) (if (> low high) '() (cons low (enumerate-interval (+ low 1) high))))")
(enumerate-interval 2 7)", "(2 3 4 5 6 7)")
(define (enumerate-tree tree) (cond ((null? tree) '()) ((not (pair? tree)) (list tree)) (else (append (enumerate-tree (car tree)) (enumerate-tree (cdr tree))))))")
(enumerate-tree (list 1 (list 2 (list 3 4)) 5))", "(1 2 3 4 5)")
(define a 1)")
(define b 2)")
(list a b)", "(1 2)")
(list 'a 'b)", "(a b)")
(list 'a b)", "(a 2)")
(car '(a b c))", "a")
(cdr '(a b c))", "(b c)")
(define (memq item x) (cond ((null? x) #f) ((equal? item (car x)) x) (else (memq item (cdr x)))))")
(memq 'apple '(pear banana prune))", "#f")
(memq 'apple '(x (apple sauce) y apple pear))", "(apple pear)")
(define (my-equal? x y) (cond ((pair? x) (and (pair? y) (my-equal? (car x) (car y)) (my-equal? (cdr x) (cdr y)))) ((null? x) (null? y)) (else (equal? x y))))")
(my-equal? '(1 2 (three)) '(1 2 (three)))", "#t")
(my-equal? '(1 2 (three)) '(1 2 three))", "#f")
(my-equal? '(1 2 three) '(1 2 (three)))", "#f")
(define double (lambda (x) (* 2 x)))")
(double 5)", "10")
(define compose (lambda (f g) (lambda (x) (f (g x)))))")
((compose list double) 5)", "(10)")
(define apply-twice (lambda (f) (compose f f)))")
((apply-twice double) 5)", "20")
((apply-twice (apply-twice double)) 5)", "80")
(define fact (lambda (n) (if (<= n 1) 1 (* n (fact (- n 1))))))")
(fact 3)", "6")
(fact 50)", "30414093201713378043612608166064768844377641568960512000000000000")
(define (combine f) (lambda (x y) (if (null? x) '() (f (list (car x) (car y)) ((combine f) (cdr x) (cdr y))))))")
(define zip (combine cons))")
(zip (list 1 2 3 4) (list 5 6 7 8))", "((1 5) (2 6) (3 7) (4 8))")
(define riff-shuffle (lambda (deck) (begin (define take (lambda (n seq) (if (<= n 0) (quote ()) (cons (car seq) (take (- n 1) (cdr seq)))))) (define drop (lambda (n seq) (if (<= n 0) seq (drop (- n 1) (cdr seq))))) (define mid (lambda (seq) (/ (length seq) 2))) ((combine append) (take (mid deck) deck) (drop (mid deck) deck)))))")
(riff-shuffle (list 1 2 3 4 5 6 7 8))", "(1 5 2 6 3 7 4 8)")
((apply-twice riff-shuffle) (list 1 2 3 4 5 6 7 8))", "(1 3 5 7 2 4 6 8)")
(riff-shuffle (riff-shuffle (riff-shuffle (list 1 2 3 4 5 6 7 8))))", "(1 2 3 4 5 6 7 8)")
(apply square '(2))", "4")
(apply + '(1 2 3 4))", "10")
(apply (if #f + append) '((1 2) (3 4)))", "(1 2 3 4)")
(define (loop) (loop))")
(cond (#f (loop)) (12))", "12")
((lambda (x) (display x) (newline) x) 2)", "2")
(let ((x 2)) ((begin (define x (+ x 1)) +) 3 (begin (define x (+ x 1)) x)))", "7")
(define (len s) (if (eq? s '()) 0 (+ 1 (len (cdr s)))))")
(len '(1 2 3 4))", "4")